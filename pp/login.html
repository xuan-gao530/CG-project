
<html>
<head>
    <style>
        body{
            background-image:url("./order05.jpg");
            background-size:cover;
        }
        canvas {
            position: absolute;z-index:-2;
            top: 0px;
            left: 0px;
            background-color: White;
        }
    </style>

    <title>Welcome to Sunny</title>

    <!--
      CanvasMatrix class
      (c) Apple Inc
      -->
    <script src="CanvasMatrix.js" type="text/javascript"></script>

    <!--
      Vertex shader
      -->
    <script id="shader-vs" type="x-shader/x-vertex">
   precision highp float;
   attribute vec3 XYZ;
   attribute vec3 RGB;
   attribute vec2 TEXC;
   uniform mat4 ProjectionMatrix;
   uniform mat4 ModelviewMatrix;
   varying vec3 col;
   varying vec2 texcoord;
   void main(void)
   {
      col =RGB;
      texcoord=TEXC;
      gl_Position = ProjectionMatrix * ModelviewMatrix * vec4(XYZ,1);
   }
</script>


    <!--
     Fragment shader
     -->
    <script id="shader-fs" type="x-shader/x-fragment">
precision highp float;
varying vec3 col;
varying vec2 texcoord;
uniform sampler2D uimage;
uniform float mode;
void main(void)
{
    if(mode==1.0 || mode ==4.0)
    {
      gl_FragColor =  vec4(col,1.0);
    }

    else if(mode==2.0|| mode ==5.0)
    {
      gl_FragColor = vec4(col,1.0)*texture2D(uimage,texcoord);
    }
    else
    {

      gl_FragColor = texture2D(uimage,texcoord);
    }

   //
}
</script>

    <!--
      WebGL program
      -->
    <script type="text/javascript">

        function CompileShader(gl,id)
        {
            //  Get shader by id
            var src = document.getElementById(id);
            //  Create shader based on type setting
            var shader;
            if (src.type == "x-shader/x-fragment")
                shader = gl.createShader(gl.FRAGMENT_SHADER);
            else if (src.type == "x-shader/x-vertex")
                shader = gl.createShader(gl.VERTEX_SHADER);
            else
                return null;
            //  Read source into str
            var str = "";
            var k = src.firstChild;
            while (k)
            {
                if (k.nodeType == 3) str += k.textContent;
                k = k.nextSibling;
            }
            gl.shaderSource(shader, str);
            //  Compile the shader
            gl.compileShader(shader);
            //  Check for errors
            if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
                alert(gl.getShaderInfoLog(shader));
            //  Return shader
            return shader;
        }

        //
        //  Compile shader program
        //
        function CompileShaderProg(gl,vert,frag)
        {
            //  Compile the program
            var prog  = gl.createProgram();
            gl.attachShader(prog , CompileShader(gl,vert));
            gl.attachShader(prog , CompileShader(gl,frag));
            gl.linkProgram(prog);
            //  Check for errors
            if (gl.getProgramParameter(prog, gl.LINK_STATUS) == 0)
                alert(gl.getProgramInfoLog(prog));
            //  Return program
            return prog;
        }

        function Cos(x) {
            return Math.cos(x*Math.PI/180);
        }

        function Sin(x) {
            return Math.sin(x*Math.PI/180);
        }

        var gl,canvas;
        function webGLStart()
        {
            //  Set canvas
            canvas = document.getElementById("canvas");
            //  Select canvas size
            var size = Math.min(window.innerWidth,window.innerHeight)-10;
            canvas.width  = window.innerWidth;
            canvas.height = 150;
            //  Start WebGL
            if (!window.WebGLRenderingContext)
            {
                alert("Your browser does not support WebGL. See http://get.webgl.org");
                return;
            }
            try
            {
                gl = canvas.getContext("experimental-webgl");
            }
            catch(e)
            {}
            if (!gl)
            {
                alert("Can't get WebGL");
                return;
            }


            //  Set viewport to entire canvas
            gl.viewport(0,0,canvas.width,canvas.height);

            //  Load Shader
            var prog = CompileShaderProg(gl,"shader-vs","shader-fs");

            //  Set program
            gl.useProgram(prog);

            //  Set projection
            var ProjectionMatrix = new CanvasMatrix4();
            ProjectionMatrix.ortho(-2.5,+2.5,-2.5,+2.5,-2.5,+2.5);

            var Vert  = [];
            var Color = [];
            var Normal = [];
            var Text   = [];

            function Vertex(th,ph)
            {
                var x = Sin(th)*Cos(ph);
                var y = Cos(th)*Cos(ph);
                var z = Sin(ph);
                //  For a sphere at the origin, the position
                //  and normal vectors are the same

                Normal.push(x,y,z);
                Text.push(th/360.0,ph/180.0+0.5);
                Vert.push(x,y,z);
                Color.push(Cos(ph), Cos(th),Sin(ph));
            }


            var hstep=0;
            var vstep=0;
            var inc =5;
            flower(-90,90,0,30);


            function flower(ah,bh,ch,dh)
            {
                function petal(offset)
                {
                    var th,ph;
                    hstep = (bh-ah)/inc;
                    vstep = (dh-ch)/inc;


                    for (ph=ah;ph<=bh;ph+=inc)
                    {
                        for (th=ch+offset;th<=dh+offset;th+=inc)
                        {
                            Vertex(th,ph);
                            Vertex(th,ph+inc);
                        }
                    }
                }
                petal(40);
                petal(140);
                petal(240);
                petal(320);

            }

            var verts = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER,verts);
            gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(Vert),gl.STATIC_DRAW);

            var color = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER,color);
            gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(Color),gl.STATIC_DRAW);

            var texcor = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER,texcor);
            gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(Text),gl.STATIC_DRAW);


            var tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,new Uint8Array([150, 184, 220, 255]));

            var image = new Image();
            image.src = "red.bmp";
            image.addEventListener('load', function() {
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);
                gl.generateMipmap(gl.TEXTURE_2D);
            });

            gl.enable(gl.DEPTH_TEST);
            gl.clearColor(1.0,1.0,1.0,1);
            var x0 = y0 = move  = 0;
            var th = ph = 15;
            DrawPart();


            function DrawPart()
            {

                gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
                // Compute modelview matrix
                var ModelviewMatrix = new CanvasMatrix4();
                ModelviewMatrix.makeIdentity();
                ModelviewMatrix.rotate(ph,0,1,0);
                ModelviewMatrix.rotate(th,1,0,0);
                gl.useProgram(prog);
                // Set projection and modelview matrixes
                gl.uniformMatrix4fv(gl.getUniformLocation(prog,"ProjectionMatrix") , false , new Float32Array(ProjectionMatrix.getAsArray()));
                gl.uniformMatrix4fv(gl.getUniformLocation(prog,"ModelviewMatrix")  , false , new Float32Array(ModelviewMatrix.getAsArray()));
                gl.uniform1i(gl.getUniformLocation(prog,"uimage"),0);

                //  Set up 3D vertex array
                gl.bindBuffer(gl.ARRAY_BUFFER,verts);
                var XYZ = gl.getAttribLocation(prog,"XYZ");
                gl.enableVertexAttribArray(XYZ);
                gl.vertexAttribPointer(XYZ,3,gl.FLOAT,false,0,0);

                gl.bindBuffer(gl.ARRAY_BUFFER,color);
                var RGB = gl.getAttribLocation(prog,"RGB");
                gl.enableVertexAttribArray(RGB);
                gl.vertexAttribPointer(RGB,3,gl.FLOAT,false,0,0);

                gl.bindBuffer(gl.ARRAY_BUFFER,texcor);
                var TEXC = gl.getAttribLocation(prog,"TEXC");
                gl.enableVertexAttribArray(TEXC);
                gl.vertexAttribPointer(TEXC,2,gl.FLOAT,false,0,0);


                const numCubes = 6;
                for (let i = 0; i <= numCubes; ++i) {
                    var ModelviewMatrix = new CanvasMatrix4();
                    ModelviewMatrix.makeIdentity();
                    ModelviewMatrix.rotate(ph,0,1,0);
                    ModelviewMatrix.rotate(th,1,0,0);
                    ModelviewMatrix.translate(-8.0 + i*3.0, 0, 0);
                    ModelviewMatrix.scale(0.15,1.0,0.15);
                    gl.uniformMatrix4fv(gl.getUniformLocation(prog,"ModelviewMatrix")  , false , new Float32Array(ModelviewMatrix.getAsArray()));
                    gl.uniform1f(gl.getUniformLocation(prog,"mode"),i);
                    gl.drawArrays(gl.TRIANGLE_STRIP,0,(hstep+1)*(vstep+1)*2*4);
                }

                gl.disableVertexAttribArray(XYZ);
                gl.disableVertexAttribArray(RGB);
                gl.disableVertexAttribArray(TEXC);
            }

            canvas.resize = function ()
            {
                canvas.width  = window.innerWidth;
                canvas.height = 150;
                gl.viewport(0,0,canvas.width,canvas.height);
                DrawPart();
            }
            canvas.onmousedown = function (ev)
            {
                move  = 1;
                x0 = ev.clientX;
                y0 = ev.clientY;
            }

            //
            //  Mouse button released
            //
            canvas.onmouseup = function (ev)
            {
                move  = 0;
            }

            //
            //  Mouse movement
            //
            canvas.onmousemove = function (ev)
            {
                if (move==0) return;
                //  Update angles
                ph -= ev.clientX-x0;
                th += ev.clientY-y0;
                //  Store location
                x0 = ev.clientX;
                y0 = ev.clientY;
                //  Redisplay
                DrawPart();
            }



        }

    </script>
</head>

<body  onload="webGLStart();"onresize="canvas.resize();">
<div id="container" style="width: 200px;margin:200px auto">
    <div id="box">
        <form action = "LoginServlet" methods="post">
            <div class="main">
                <div>
                    <label style="font-size:20px;color:#330066"> Username: </label>
                    <input name = "username" value="">
                </div>
                <div>
                    <label  style="font-size:20px;color:#330066"> Password:</label>
                    <input type ="password" name="password",value="">
                </div>
                <div>
                    <br /><input type ="submit" value="login" style="color:#330066;font-size:20px;background-color:transparent;">
                </div>
            </div>
        </form>
    </div>
</div>
<canvas id="canvas" width="200" height="100"></canvas>
</body>
</html>

